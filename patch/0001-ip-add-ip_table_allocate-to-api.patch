From 59d89c746663a6acaa89e9d94890f48fa4ec4903 Mon Sep 17 00:00:00 2001
From: Artem Glazychev <artem.glazychev@xored.com>
Date: Thu, 23 Sep 2021 19:18:28 +0700
Subject: [PATCH] ip: add ip_table_allocate to api

Set tableID = ~0 for auto selection unused ID

https://jira.fd.io/browse/VPP-1993

Type: improvement
Change-Id: I4eec2cc1d18fc025196cb6ac4c9a4b374388eb56
Signed-off-by: Artem Glazychev <artem.glazychev@xored.com>
Signed-off-by: Aloys Augustin <aloaugus@cisco.com>

# Conflicts:
#	src/vnet/ip/ip_test.c
---
 src/vnet/fib/fib_table.c            |   3 +-
 src/vnet/ip/ip.api                  |  31 ++++++-
 src/vnet/ip/ip.h                    |   2 +
 src/vnet/ip/ip_api.c                |  50 +++++++++++
 src/vnet/ip/lookup.c                |  33 ++++----
 test/test_ip4_vrf_multi_instance.py | 107 +++++++++++++++++++-----
 test/test_ip6_vrf_multi_instance.py | 123 ++++++++++++++++++++++------
 7 files changed, 286 insertions(+), 63 deletions(-)

diff --git a/src/vnet/fib/fib_table.c b/src/vnet/fib/fib_table.c
index eaeee5bb9..de348efa3 100644
--- a/src/vnet/fib/fib_table.c
+++ b/src/vnet/fib/fib_table.c
@@ -1317,6 +1317,7 @@ fib_table_lock_dec (fib_table_t *fib_table,
 {
     vec_validate(fib_table->ft_locks, source);
 
+    ASSERT(fib_table->ft_locks[source] > 0);
     fib_table->ft_locks[source]--;
     fib_table->ft_total_locks--;
 }
@@ -1345,7 +1346,7 @@ fib_table_unlock (u32 fib_index,
     if (0 == fib_table->ft_total_locks)
     {
         /*
-         * no more locak from any source - kill it
+         * no more lock from any source - kill it
          */
 	fib_table_destroy(fib_table);
     }
diff --git a/src/vnet/ip/ip.api b/src/vnet/ip/ip.api
index c8d4c3971..c26512faf 100644
--- a/src/vnet/ip/ip.api
+++ b/src/vnet/ip/ip.api
@@ -20,7 +20,7 @@
     called through a shared memory interface.
 */
 
-option version = "3.1.0";
+option version = "3.2.0";
 
 import "vnet/interface_types.api";
 import "vnet/fib/fib_types.api";
@@ -57,6 +57,35 @@ autoreply define ip_table_add_del
   vl_api_ip_table_t table;
 };
 
+/** \brief Allocate an unused table
+           A table can be added multiple times.
+           If a large number of tables are in use (millions), this API might
+           fail to find a free ID with very low probability, and will return
+           EAGAIN. A subsequent attempt may be successful.
+  @param client_index - opaque cookie to identify the sender
+  @param context - sender context, to match reply w/ request
+  @param table - if table.table_id == ~0, vpp allocates an unused table_id and
+                    proceeds as in ip_table_add_del with is_add = true
+                 if table.table_id != ~0, vpp uses the table.table_id and
+                    proceeds as in ip_table_add_del with is_add = true
+                 table.table_id should never be 0
+*/
+define ip_table_allocate
+{
+  u32 client_index;
+  u32 context;
+
+  vl_api_ip_table_t table;
+};
+
+define ip_table_allocate_reply
+{
+  u32 context;
+  i32 retval;
+
+  vl_api_ip_table_t table;
+};
+
 /** \brief Dump IP all fib tables
     @param client_index - opaque cookie to identify the sender
     @param context - sender context, to match reply w/ request
diff --git a/src/vnet/ip/ip.h b/src/vnet/ip/ip.h
index 6d822d29d..cda0de2a4 100644
--- a/src/vnet/ip/ip.h
+++ b/src/vnet/ip/ip.h
@@ -270,6 +270,8 @@ void ip_table_delete (fib_protocol_t fproto, u32 table_id, u8 is_api);
 int ip_table_bind (fib_protocol_t fproto, u32 sw_if_index,
 		   u32 table_id, u8 is_api);
 
+u32 ip_table_get_unused_id (fib_protocol_t fproto);
+
 u8 ip_is_zero (ip46_address_t * ip46_address, u8 is_ip4);
 u8 ip_is_local_host (ip46_address_t * ip46_address, u8 is_ip4);
 u8 ip4_is_local_host (ip4_address_t * ip4_address);
diff --git a/src/vnet/ip/ip_api.c b/src/vnet/ip/ip_api.c
index 91b12e589..c1c02e3a8 100644
--- a/src/vnet/ip/ip_api.c
+++ b/src/vnet/ip/ip_api.c
@@ -80,6 +80,7 @@
   _ (IP_ADDRESS_DUMP, ip_address_dump)                                        \
   _ (IP_UNNUMBERED_DUMP, ip_unnumbered_dump)                                  \
   _ (IP_DUMP, ip_dump)                                                        \
+  _ (IP_TABLE_ALLOCATE, ip_table_allocate)                                    \
   _ (IP_TABLE_REPLACE_BEGIN, ip_table_replace_begin)                          \
   _ (IP_TABLE_REPLACE_END, ip_table_replace_end)                              \
   _ (IP_TABLE_FLUSH, ip_table_flush)                                          \
@@ -610,6 +611,32 @@ ip_table_delete (fib_protocol_t fproto, u32 table_id, u8 is_api)
     }
 }
 
+/*
+ * Returns an unused table id, and ~0 if it can't find one.
+ */
+u32
+ip_table_get_unused_id (fib_protocol_t fproto)
+{
+  int i, j;
+  u32 seed = random_default_seed ();
+  /* limit to 1M tries */
+  for (j = 0; j < 1 << 10; j++)
+    {
+      seed = random_u32 (&seed);
+      for (i = 0; i < 1 << 10; i++)
+	{
+	  /* look around randomly generated id */
+	  seed += (2 * (i % 2) - 1) * i;
+	  if (seed == ~0)
+	    continue;
+	  if (fib_table_find (fproto, seed) == ~0)
+	    return seed;
+	}
+    }
+
+  return ~0;
+}
+
 void
 vl_api_ip_table_add_del_t_handler (vl_api_ip_table_add_del_t * mp)
 {
@@ -631,6 +658,29 @@ vl_api_ip_table_add_del_t_handler (vl_api_ip_table_add_del_t * mp)
   REPLY_MACRO (VL_API_IP_TABLE_ADD_DEL_REPLY);
 }
 
+void
+vl_api_ip_table_allocate_t_handler (vl_api_ip_table_allocate_t *mp)
+{
+  vl_api_ip_table_allocate_reply_t *rmp;
+  fib_protocol_t fproto =
+    (mp->table.is_ip6 ? FIB_PROTOCOL_IP6 : FIB_PROTOCOL_IP4);
+  u32 table_id = ntohl (mp->table.table_id);
+  int rv = 0;
+
+  if (~0 == table_id)
+    table_id = ip_table_get_unused_id (fproto);
+
+  if (~0 == table_id)
+    rv = VNET_API_ERROR_EAGAIN;
+  else
+    ip_table_create (fproto, table_id, 1, mp->table.name);
+
+  REPLY_MACRO2 (VL_API_IP_TABLE_ALLOCATE_REPLY, {
+    clib_memcpy_fast (&rmp->table, &mp->table, sizeof (mp->table));
+    rmp->table.table_id = htonl (table_id);
+  })
+}
+
 static int
 ip_route_add_del_t_handler (vl_api_ip_route_add_del_t * mp, u32 * stats_index)
 {
diff --git a/src/vnet/ip/lookup.c b/src/vnet/ip/lookup.c
index f674fec48..ad96a7ac8 100644
--- a/src/vnet/ip/lookup.c
+++ b/src/vnet/ip/lookup.c
@@ -399,27 +399,32 @@ vnet_ip_table_cmd (vlib_main_t * vm,
 	}
     }
 
-  if (~0 == table_id)
-    {
-      error = clib_error_return (0, "No table id");
-      goto done;
-    }
-  else if (0 == table_id)
+  if (0 == table_id)
     {
       error = clib_error_return (0, "Can't change the default table");
       goto done;
     }
   else
-    {
-      if (is_add)
 	{
-	  ip_table_create (fproto, table_id, 0, name);
-	}
-      else
-	{
-	  ip_table_delete (fproto, table_id, 0);
+	  if (is_add)
+	    {
+	      if (~0 == table_id)
+		{
+		  table_id = ip_table_get_unused_id (fproto);
+		  vlib_cli_output (vm, "%u\n", table_id);
+		}
+	      ip_table_create (fproto, table_id, 0, name);
+	    }
+	  else
+	    {
+	      if (~0 == table_id)
+		{
+		  error = clib_error_return (0, "No table id");
+		  goto done;
+		}
+	      ip_table_delete (fproto, table_id, 0);
+	    }
 	}
-    }
 
 done:
   unformat_free (line_input);
diff --git a/test/test_ip4_vrf_multi_instance.py b/test/test_ip4_vrf_multi_instance.py
index 6444b97a3..03ba5a950 100644
--- a/test/test_ip4_vrf_multi_instance.py
+++ b/test/test_ip4_vrf_multi_instance.py
@@ -136,13 +136,13 @@ class TestIp4VrfMultiInst(VppTestCase):
             cls.pg_not_in_vrf = [pg_if for pg_if in cls.pg_interfaces]
 
             # Create mapping of pg_interfaces to VRF IDs
-            cls.pg_if_by_vrf_id = dict()
+            cls.pg_if_sets = dict()
             for i in range(cls.nr_of_vrfs):
-                vrf_id = i + 1
+                set_id = i + 1
                 pg_list = [
                     cls.pg_interfaces[i * cls.pg_ifs_per_vrf + j]
                     for j in range(cls.pg_ifs_per_vrf)]
-                cls.pg_if_by_vrf_id[vrf_id] = pg_list
+                cls.pg_if_sets[set_id] = pg_list
 
         except Exception:
             super(TestIp4VrfMultiInst, cls).tearDownClass()
@@ -169,6 +169,19 @@ class TestIp4VrfMultiInst(VppTestCase):
         self.logger.info(self.vapi.ppcli("show ip fib"))
         self.logger.info(self.vapi.ppcli("show ip4 neighbors"))
 
+    def _assign_interfaces(self, vrf_id, if_set_id):
+        for i in range(self.pg_ifs_per_vrf):
+            pg_if = self.pg_if_sets[if_set_id][i]
+            pg_if.set_table_ip4(vrf_id)
+            self.logger.info("pg-interface %s added to IPv4 VRF ID %d"
+                             % (pg_if.name, vrf_id))
+            if pg_if not in self.pg_in_vrf:
+                self.pg_in_vrf.append(pg_if)
+            if pg_if in self.pg_not_in_vrf:
+                self.pg_not_in_vrf.remove(pg_if)
+            pg_if.config_ip4()
+            pg_if.configure_ipv4_neighbors()
+
     def create_vrf_and_assign_interfaces(self, count, start=1):
         """
         Create required number of FIB tables / VRFs, put 3 pg-ip4 interfaces
@@ -181,40 +194,53 @@ class TestIp4VrfMultiInst(VppTestCase):
 
         for i in range(count):
             vrf_id = i + start
-            pg_if = self.pg_if_by_vrf_id[vrf_id][0]
             self.vapi.ip_table_add_del(is_add=1, table={'table_id': vrf_id})
             self.logger.info("IPv4 VRF ID %d created" % vrf_id)
             if vrf_id not in self.vrf_list:
                 self.vrf_list.append(vrf_id)
             if vrf_id in self.vrf_reset_list:
                 self.vrf_reset_list.remove(vrf_id)
-            for j in range(self.pg_ifs_per_vrf):
-                pg_if = self.pg_if_by_vrf_id[vrf_id][j]
-                pg_if.set_table_ip4(vrf_id)
-                self.logger.info("pg-interface %s added to IPv4 VRF ID %d"
-                                 % (pg_if.name, vrf_id))
-                if pg_if not in self.pg_in_vrf:
-                    self.pg_in_vrf.append(pg_if)
-                if pg_if in self.pg_not_in_vrf:
-                    self.pg_not_in_vrf.remove(pg_if)
-                pg_if.config_ip4()
-                pg_if.configure_ipv4_neighbors()
+            self._assign_interfaces(vrf_id, vrf_id)
         self.logger.debug(self.vapi.ppcli("show ip fib"))
         self.logger.debug(self.vapi.ppcli("show ip4 neighbors"))
 
-    def reset_vrf_and_remove_from_vrf_list(self, vrf_id):
+    def create_vrf_by_id_and_assign_interfaces(self, set_id,
+                                               vrf_id=0xffffffff):
+        """
+        Create a FIB table / VRF by vrf_id, put 3 pg-ip4 interfaces
+        to FIB table / VRF.
+
+        :param int vrf_id: Required table ID / VRF ID. \
+        (Default value = 0xffffffff, ID will be selected automatically)
+        """
+        ret = self.vapi.ip_table_allocate(table={'table_id': vrf_id})
+        vrf_id = ret.table.table_id
+        self.logger.info("IPv4 VRF ID %d created" % vrf_id)
+        if vrf_id not in self.vrf_list:
+            self.vrf_list.append(vrf_id)
+        if vrf_id in self.vrf_reset_list:
+            self.vrf_reset_list.remove(vrf_id)
+        self._assign_interfaces(vrf_id, set_id)
+        self.logger.debug(self.vapi.ppcli("show ip fib"))
+        self.logger.debug(self.vapi.ppcli("show ip4 neighbors"))
+
+        return vrf_id
+
+    def reset_vrf_and_remove_from_vrf_list(self, vrf_id, if_set_id=None):
         """
         Reset required FIB table / VRF and remove it from VRF list.
 
         :param int vrf_id: The FIB table / VRF ID to be reset.
         """
+        if if_set_id is None:
+            if_set_id = vrf_id
         self.vapi.ip_table_flush(table={'table_id': vrf_id})
         if vrf_id in self.vrf_list:
             self.vrf_list.remove(vrf_id)
         if vrf_id not in self.vrf_reset_list:
             self.vrf_reset_list.append(vrf_id)
         for j in range(self.pg_ifs_per_vrf):
-            pg_if = self.pg_if_by_vrf_id[vrf_id][j]
+            pg_if = self.pg_if_sets[if_set_id][j]
             pg_if.unconfig_ip4()
             if pg_if in self.pg_in_vrf:
                 self.pg_in_vrf.remove(pg_if)
@@ -267,7 +293,7 @@ class TestIp4VrfMultiInst(VppTestCase):
         vrf_lst = list(self.vrf_list)
         vrf_lst.remove(vrf_id)
         for vrf in vrf_lst:
-            for dst_if in self.pg_if_by_vrf_id[vrf]:
+            for dst_if in self.pg_if_sets[vrf]:
                 for dst_host in dst_if.remote_hosts:
                     src_host = random.choice(src_hosts)
                     pkt_info = self.create_packet_info(src_if, dst_if)
@@ -327,20 +353,22 @@ class TestIp4VrfMultiInst(VppTestCase):
                 "Port %u: Packet expected from source %u didn't arrive" %
                 (dst_sw_if_index, i.sw_if_index))
 
-    def verify_vrf(self, vrf_id):
+    def verify_vrf(self, vrf_id, if_set_id=None):
         """
         Check if the FIB table / VRF ID is configured.
 
         :param int vrf_id: The FIB table / VRF ID to be verified.
         :return: 1 if the FIB table / VRF ID is configured, otherwise return 0.
         """
+        if if_set_id is None:
+            if_set_id = vrf_id
         ip_fib_dump = self.vapi.ip_route_dump(vrf_id)
         vrf_exist = len(ip_fib_dump)
         vrf_count = 0
         for ip_fib_details in ip_fib_dump:
             addr = ip_fib_details.route.prefix.network_address
             found = False
-            for pg_if in self.pg_if_by_vrf_id[vrf_id]:
+            for pg_if in self.pg_if_sets[if_set_id]:
                 if found:
                     break
                 for host in pg_if.remote_hosts:
@@ -405,7 +433,7 @@ class TestIp4VrfMultiInst(VppTestCase):
         # Test
         # Create incoming packet streams for packet-generator interfaces
         for vrf_id in self.vrf_list:
-            for pg_if in self.pg_if_by_vrf_id[vrf_id]:
+            for pg_if in self.pg_if_sets[vrf_id]:
                 pkts = self.create_stream_crosswise_vrf(
                     pg_if, vrf_id, self.pg_if_packet_sizes)
                 pg_if.add_stream(pkts)
@@ -498,6 +526,43 @@ class TestIp4VrfMultiInst(VppTestCase):
         self.run_verify_test()
         self.run_crosswise_vrf_test()
 
+    def test_ip4_vrf_05(self):
+        """ IP4 VRF  Multi-instance test 5 - id allocation
+        """
+        # Config 5
+        # Create several VRFs
+        # Set vrf_id manually first
+        self.create_vrf_by_id_and_assign_interfaces(1, 1)
+        # Set vrf_id automatically a few times
+        auto_vrf_id = [
+            self.create_vrf_by_id_and_assign_interfaces(i) for i in range(2, 5)
+        ]
+
+        # Verify 5
+        self.assert_equal(self.verify_vrf(1, 1), VRFState.configured, VRFState)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.assert_equal(self.verify_vrf(vrf, i+2),
+                              VRFState.configured, VRFState)
+
+        # Test 5
+        self.run_verify_test()
+
+        # Config 5.1
+        # Reset VRFs
+        self.reset_vrf_and_remove_from_vrf_list(1)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.reset_vrf_and_remove_from_vrf_list(vrf, i+2)
+
+        # Verify 5.1
+        self.assert_equal(self.verify_vrf(1, 1), VRFState.reset, VRFState)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.assert_equal(self.verify_vrf(vrf, i+2),
+                              VRFState.reset, VRFState)
+
+        vrf_list_length = len(self.vrf_list)
+        self.assertEqual(
+            vrf_list_length, 0,
+            "List of configured VRFs is not empty: %s != 0" % vrf_list_length)
 
 if __name__ == '__main__':
     unittest.main(testRunner=VppTestRunner)
diff --git a/test/test_ip6_vrf_multi_instance.py b/test/test_ip6_vrf_multi_instance.py
index 16069b260..febc0ee35 100644
--- a/test/test_ip6_vrf_multi_instance.py
+++ b/test/test_ip6_vrf_multi_instance.py
@@ -148,13 +148,13 @@ class TestIP6VrfMultiInst(VppTestCase):
             cls.pg_not_in_vrf = [pg_if for pg_if in cls.pg_interfaces]
 
             # Create mapping of pg_interfaces to VRF IDs
-            cls.pg_if_by_vrf_id = dict()
+            cls.pg_if_sets = dict()
             for i in range(cls.nr_of_vrfs):
-                vrf_id = i + 1
+                set_id = i + 1
                 pg_list = [
                     cls.pg_interfaces[i * cls.pg_ifs_per_vrf + j]
                     for j in range(cls.pg_ifs_per_vrf)]
-                cls.pg_if_by_vrf_id[vrf_id] = pg_list
+                cls.pg_if_sets[set_id] = pg_list
 
         except Exception:
             super(TestIP6VrfMultiInst, cls).tearDownClass()
@@ -181,6 +181,20 @@ class TestIP6VrfMultiInst(VppTestCase):
         self.logger.info(self.vapi.ppcli("show ip6 fib"))
         self.logger.info(self.vapi.ppcli("show ip6 neighbors"))
 
+    def _assign_interfaces(self, vrf_id, if_set_id):
+        for i in range(self.pg_ifs_per_vrf):
+            pg_if = self.pg_if_sets[if_set_id][i]
+            pg_if.set_table_ip6(vrf_id)
+            self.logger.info("pg-interface %s added to IPv6 VRF ID %d"
+                             % (pg_if.name, vrf_id))
+            if pg_if not in self.pg_in_vrf:
+                self.pg_in_vrf.append(pg_if)
+            if pg_if in self.pg_not_in_vrf:
+                self.pg_not_in_vrf.remove(pg_if)
+            pg_if.config_ip6()
+            pg_if.disable_ipv6_ra()
+            pg_if.configure_ipv6_neighbors()
+
     def create_vrf_and_assign_interfaces(self, count, start=1):
         """
         Create required number of FIB tables / VRFs, put 3 pg-ip6 interfaces
@@ -192,7 +206,6 @@ class TestIP6VrfMultiInst(VppTestCase):
         """
         for i in range(count):
             vrf_id = i + start
-            pg_if = self.pg_if_by_vrf_id[vrf_id][0]
             self.vapi.ip_table_add_del(is_add=1,
                                        table={'table_id': vrf_id, 'is_ip6': 1})
             self.logger.info("IPv6 VRF ID %d created" % vrf_id)
@@ -200,34 +213,48 @@ class TestIP6VrfMultiInst(VppTestCase):
                 self.vrf_list.append(vrf_id)
             if vrf_id in self.vrf_reset_list:
                 self.vrf_reset_list.remove(vrf_id)
-            for j in range(self.pg_ifs_per_vrf):
-                pg_if = self.pg_if_by_vrf_id[vrf_id][j]
-                pg_if.set_table_ip6(vrf_id)
-                self.logger.info("pg-interface %s added to IPv6 VRF ID %d"
-                                 % (pg_if.name, vrf_id))
-                if pg_if not in self.pg_in_vrf:
-                    self.pg_in_vrf.append(pg_if)
-                if pg_if in self.pg_not_in_vrf:
-                    self.pg_not_in_vrf.remove(pg_if)
-                pg_if.config_ip6()
-                pg_if.disable_ipv6_ra()
-                pg_if.configure_ipv6_neighbors()
+            self._assign_interfaces(vrf_id, vrf_id)
+        self.logger.debug(self.vapi.ppcli("show ip6 fib"))
+        self.logger.debug(self.vapi.ppcli("show ip6 neighbors"))
+
+    def create_vrf_by_id_and_assign_interfaces(self, set_id,
+                                               vrf_id=0xffffffff):
+        """
+        Create a FIB table / VRF by vrf_id, put 3 pg-ip6 interfaces
+        to FIB table / VRF.
+
+        :param int vrf_id: Required table ID / VRF ID. \
+        (Default value = 0xffffffff, ID will be selected automatically)
+        """
+        ret = self.vapi.ip_table_allocate(table={'table_id': vrf_id,
+                                                 'is_ip6': 1})
+        vrf_id = ret.table.table_id
+        self.logger.info("IPv6 VRF ID %d created" % vrf_id)
+        if vrf_id not in self.vrf_list:
+            self.vrf_list.append(vrf_id)
+        if vrf_id in self.vrf_reset_list:
+            self.vrf_reset_list.remove(vrf_id)
+        self._assign_interfaces(vrf_id, set_id)
         self.logger.debug(self.vapi.ppcli("show ip6 fib"))
         self.logger.debug(self.vapi.ppcli("show ip6 neighbors"))
 
-    def reset_vrf_and_remove_from_vrf_list(self, vrf_id):
+        return vrf_id
+
+    def reset_vrf_and_remove_from_vrf_list(self, vrf_id, if_set_id=None):
         """
         Reset required FIB table / VRF and remove it from VRF list.
 
         :param int vrf_id: The FIB table / VRF ID to be reset.
         """
+        if if_set_id is None:
+            if_set_id = vrf_id
         self.vapi.ip_table_flush(table={'table_id': vrf_id, 'is_ip6': 1})
         if vrf_id in self.vrf_list:
             self.vrf_list.remove(vrf_id)
         if vrf_id not in self.vrf_reset_list:
             self.vrf_reset_list.append(vrf_id)
         for j in range(self.pg_ifs_per_vrf):
-            pg_if = self.pg_if_by_vrf_id[vrf_id][j]
+            pg_if = self.pg_if_sets[if_set_id][j]
             pg_if.unconfig_ip6()
             if pg_if in self.pg_in_vrf:
                 self.pg_in_vrf.remove(pg_if)
@@ -281,7 +308,7 @@ class TestIP6VrfMultiInst(VppTestCase):
         vrf_lst = list(self.vrf_list)
         vrf_lst.remove(vrf_id)
         for vrf in vrf_lst:
-            for dst_if in self.pg_if_by_vrf_id[vrf]:
+            for dst_if in self.pg_if_sets[vrf]:
                 for dst_host in dst_if.remote_hosts:
                     src_host = random.choice(src_hosts)
                     pkt_info = self.create_packet_info(src_if, dst_if)
@@ -341,20 +368,22 @@ class TestIP6VrfMultiInst(VppTestCase):
                 "Port %u: Packet expected from source %u didn't arrive" %
                 (dst_sw_if_index, i.sw_if_index))
 
-    def verify_vrf(self, vrf_id):
+    def verify_vrf(self, vrf_id, if_set_id=None):
         """
         Check if the FIB table / VRF ID is configured.
 
         :param int vrf_id: The FIB table / VRF ID to be verified.
         :return: 1 if the FIB table / VRF ID is configured, otherwise return 0.
         """
+        if if_set_id is None:
+            if_set_id = vrf_id
         ip6_fib_dump = self.vapi.ip_route_dump(vrf_id, True)
         vrf_exist = len(ip6_fib_dump)
         vrf_count = 0
         for ip6_fib_details in ip6_fib_dump:
             addr = ip6_fib_details.route.prefix.network_address
             found = False
-            for pg_if in self.pg_if_by_vrf_id[vrf_id]:
+            for pg_if in self.pg_if_sets[if_set_id]:
                 if found:
                     break
                 for host in pg_if.remote_hosts:
@@ -419,7 +448,7 @@ class TestIP6VrfMultiInst(VppTestCase):
         # Test
         # Create incoming packet streams for packet-generator interfaces
         for vrf_id in self.vrf_list:
-            for pg_if in self.pg_if_by_vrf_id[vrf_id]:
+            for pg_if in self.pg_if_sets[vrf_id]:
                 pkts = self.create_stream_crosswise_vrf(
                     pg_if, vrf_id, self.pg_if_packet_sizes)
                 pg_if.add_stream(pkts)
@@ -472,8 +501,8 @@ class TestIP6VrfMultiInst(VppTestCase):
         self.run_crosswise_vrf_test()
 
         # Reset routes learned from ICMPv6 Neighbor Discovery
-        for vrf_id in self.vrf_reset_list:
-            self.reset_vrf_and_remove_from_vrf_list(vrf_id)
+        # for vrf_id in self.vrf_reset_list:
+        #     self.reset_vrf_and_remove_from_vrf_list(vrf_id)
 
     def test_ip6_vrf_03(self):
         """ IP6 VRF  Multi-instance 3 - add 2 VRFs
@@ -496,8 +525,8 @@ class TestIP6VrfMultiInst(VppTestCase):
         self.run_crosswise_vrf_test()
 
         # Reset routes learned from ICMPv6 Neighbor Discovery
-        for vrf_id in self.vrf_reset_list:
-            self.reset_vrf_and_remove_from_vrf_list(vrf_id)
+        # for vrf_id in self.vrf_reset_list:
+        #     self.reset_vrf_and_remove_from_vrf_list(vrf_id)
 
     def test_ip6_vrf_04(self):
         """ IP6 VRF  Multi-instance test 4 - reset 4 VRFs
@@ -505,6 +534,7 @@ class TestIP6VrfMultiInst(VppTestCase):
         # Config 4
         # Reset all VRFs (i.e. no VRF except VRF=0 configured)
         for i in range(len(self.vrf_list)):
+            # This call removes the first item of vrf_list as a side effect
             self.reset_vrf_and_remove_from_vrf_list(self.vrf_list[0])
 
         # Verify 4
@@ -520,6 +550,47 @@ class TestIP6VrfMultiInst(VppTestCase):
         self.run_verify_test()
         self.run_crosswise_vrf_test()
 
+    @unittest.skip('VPP crashes after running this test. \
+    There seems to be an issue with the way fib locks are managed')
+    def test_ip6_vrf_05(self):
+        """ IP6 VRF  Multi-instance test 5 - auto allocate vrf id
+        """
+        # Config 5
+        # Create several VRFs
+        # Set vrf_id manually first
+        self.create_vrf_by_id_and_assign_interfaces(1, 10)
+        # Set vrf_id automatically a few times
+        auto_vrf_id = [
+            self.create_vrf_by_id_and_assign_interfaces(i) for i in range(2, 5)
+        ]
+
+        # Verify 5
+        self.assert_equal(self.verify_vrf(10, 1), VRFState.configured,
+                          VRFState)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.assert_equal(self.verify_vrf(vrf, i+2),
+                              VRFState.configured, VRFState)
+
+        # Test 5
+        self.run_verify_test()
+
+        # Config 5.1
+        # Reset VRFs
+        self.reset_vrf_and_remove_from_vrf_list(10, 1)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.reset_vrf_and_remove_from_vrf_list(vrf, i+2)
+
+        # Verify 5.1
+        self.assert_equal(self.verify_vrf(10, 1), VRFState.reset, VRFState)
+        for i, vrf in enumerate(auto_vrf_id):
+            self.assert_equal(self.verify_vrf(vrf, i+2),
+                              VRFState.reset, VRFState)
+
+        vrf_list_length = len(self.vrf_list)
+        self.assertEqual(
+            vrf_list_length, 0,
+            "List of configured VRFs is not empty: %s != 0" % vrf_list_length)
+
 
 if __name__ == '__main__':
     unittest.main(testRunner=VppTestRunner)
-- 
2.25.1

